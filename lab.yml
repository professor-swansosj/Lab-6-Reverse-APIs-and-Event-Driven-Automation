# ==========================================
# Course: Software Defined Networking
# Module: Reverse APIs & Event-Driven Automation (Webhooks)
# Purpose: Hands on activity for developing webhook listeners with FastAPI
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 6 — Reverse APIs & Event-Driven Automation (Webhooks)"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 6
time_estimate: "120–150 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "What is a Webhook?"
    content: > 
      A webhook is a user-defined HTTP callback that is triggered by specific events. When an event occurs in a service, 
      the webhook sends a POST request to a specified URL with a payload containing information about the event. This allows 
      for real-time communication between services and enables event-driven architectures.

      Common use cases for webhooks include in networking, where a network device or management system can notify an external
      application of configuration changes, alerts, or status updates. This is in contrast to traditional request/response APIs, 
      where the client must poll the server for updates.

      Example services in networking that utilize webhooks include Cisco's Event-Driven Network Management (EDNM) platform, which 
      can trigger workflows based on network events. Webhooks typically consist of:
      - **URL**: The endpoint where the webhook payload is sent.
      - **Headers**: Metadata about the request, such as content type and authentication tokens.
      - **Payload**: The data sent in the body of the POST request, usually in JSON format.

  - title: "API vs Webhook"
    content: > 
      Traditional APIs operate on a request/response model, where a client sends a request to a server and waits for a response. 
      This often involves polling the server at regular intervals to check for updates, which can lead to inefficiencies and delays.

      In contrast, webhooks follow a push model, where the server proactively sends data to the client when an event occurs. 
      This allows for real-time updates and reduces the need for constant polling, making webhooks more efficient for event-driven scenarios.

      Key differences include:
      - **Initiation**: APIs require the client to initiate requests; webhooks are initiated by the server.
      - **Timing**: APIs may involve delays due to polling intervals; webhooks provide immediate notifications.
      - **Resource Usage**: APIs can consume more resources due to frequent polling; webhooks are more efficient as they only send data when necessary.

  - title: "Webhooks in Networking"
    content: > 
      Webhooks are particularly useful in networking for real-time event notifications. For example, Cisco's Event-Driven Network Management (EDNM) platform utilizes webhooks to trigger workflows based on network events. This allows network administrators to respond quickly to changes in the network environment.

      In a typical webhook setup for networking, the following components are involved:
      - **Event Source**: The network device or management system that generates events (e.g., configuration changes, alerts).
      - **Webhook Listener**: The endpoint that receives webhook notifications (e.g., a FastAPI application).
      - **Payload**: The data sent in the webhook notification, which may include details about the event and relevant context.

      By leveraging webhooks, networking tools can achieve greater automation and responsiveness, enabling more efficient management of network resources.

  - title: "Cisco EDNM & Webhooks"
    content: > 
      Cisco's Event-Driven Network Management (EDNM) platform is a powerful tool that utilizes webhooks to enable event-driven automation in networking. EDNM allows network administrators to define workflows that are triggered by specific events, such as configuration changes, device status updates, or security alerts.

      In an EDNM setup, webhooks play a crucial role in facilitating communication between the network management system and external applications. When an event occurs, EDNM sends a webhook notification to a predefined URL, allowing the receiving application to process the event and take appropriate actions.

      Key features of Cisco EDNM with webhooks include:
      - **Event Triggers**: Define specific events that will trigger webhook notifications.
      - **Custom Payloads**: Configure the data sent in the webhook payload to include relevant information about the event.
      - **Integration**: Easily integrate with other systems and applications using webhooks, enabling seamless automation across different platforms.

      By leveraging webhooks in Cisco EDNM, network administrators can create dynamic and responsive workflows that enhance network management and improve operational efficiency.

      An example configuration snippet for setting up a webhook in Cisco EDNM might look like the example below:

    code_block:
      language: "bash"
      code: |
        router(config)# event manager applet Webhook_Example
        router(config-applet)# event syslog pattern "LINK-3-UPDOWN"
        router(config-applet)# action 1.0 cli command "enable"
        router(config-applet)# action 1.1 cli command "configure terminal"
        router(config-applet)# action 1.2 cli command "interface GigabitEthernet0/1"
        router(config-applet)# action 1.3 cli command "description Link is up"
        router(config-applet)# action 1.4 cli command "end"
        router(config-applet)# action 1.5 http post url "http://your-webhook-url" body "Interface GigabitEthernet0/1 is up"
        router(config-applet)# action 1.6 exit
        router(config-applet)# exit
        router(config)# exit

    code_notes: |
      In this example, the Event Manager applet is configured to listen for syslog messages indicating a link status change. When the specified 
      event occurs, the applet executes a series of CLI commands to update the interface description and then sends a webhook notification to 
      the specified URL with a message about the link status change. This demonstrates how webhooks can be used in conjunction with network 
      events to automate responses and notify external systems.

  - title: "Creating Webhook Listeners with FastAPI"
    content: > 
      FastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.7+ based on standard Python type hints. It is particularly well-suited for creating webhook listeners due to its simplicity and efficiency.

      To create a webhook listener with FastAPI, you typically define an endpoint that accepts POST requests. The endpoint processes the incoming JSON payload and performs actions based on the event data.

      Here’s a basic example of a FastAPI webhook listener:

    code_block:
      language: "python"
      code: |
        from fastapi import FastAPI

        app = FastAPI()

        @app.post("/webhook")
        async def handle_webhook(payload: dict):
            # Process the incoming webhook payload
            print("Received webhook payload:", payload)
            return {"status": "success"}

    code_notes: |
      In this example, the FastAPI application defines a POST endpoint at `/webhook`. When a webhook notification is received, the `handle_webhook` function is called with the JSON payload parsed into a Python dictionary. The function can then process the payload as needed and return a response.

      To run the FastAPI application, you can use Uvicorn, an ASGI server:

      ```bash
      pip install uvicorn
      uvicorn main:app --reload
      ```
      This will start the server, and you can test the webhook listener by sending a POST request with a JSON payload using tools like cURL or Postman.

      ```bash
      curl -X POST "http://localhost:8000/webhook" -H "Content-Type: application/json" -d '{"event": "test_event", "data": "sample_data"}'
      ```
  
  - title: "Security Considerations for Webhooks"
    content: > 
      When implementing webhooks, it is crucial to consider security aspects to protect against unauthorized access and ensure the integrity of the data being transmitted. Here are some best practices for securing webhooks:

      1. **Validation**: Always validate incoming webhook requests to ensure they originate from a trusted source. This can be done by checking headers, IP addresses, or using shared secrets.

      2. **Authentication**: Implement authentication mechanisms such as HMAC signatures or bearer tokens to verify the authenticity of the webhook requests.

      3. **Rate Limiting**: Apply rate limiting to prevent abuse and mitigate denial-of-service (DoS) attacks.

      4. **Payload Size Limits**: Set limits on the size of incoming payloads to avoid resource exhaustion.

      5. **HTTPS**: Use HTTPS to encrypt data in transit and protect against eavesdropping and man-in-the-middle attacks.


#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================
# LAB 6 — REVERSE APIs & EVENT-DRIVEN AUTOMATION (FastAPI Webhooks + EEM)
# Software Defined Networking • Florida State College at Jacksonville
# Worth 75 points

# OBJECTIVES
objectives:
  - "Explain webhooks (reverse APIs) and event-driven automation."
  - "Build a FastAPI webhook service with ≥5 paths (joke, card draw, Netmiko, RESTCONF, NETCONF)."
  - "Secure endpoints with a shared token; implement validation and logging."
  - "Persist artifacts (raw responses and summaries) for grading."
  - "Configure a Cisco EEM applet to call the webhook on interface-down and back up device config."

# PREREQUISITES
python_version: "3.11"
accounts: ["GitHub", "Cisco DevNet"]
devices:
  - "Local FastAPI server"
  - "Cisco DevNet Always-On Catalyst 8k/9k (SSH/RESTCONF/NETCONF)"

prereq:
  - "Intermediate Python (functions, modules, exceptions, logging)."
  - "FastAPI + Uvicorn basics."
  - "requests, netmiko, ncclient, and xmltodict usage."
  - "cURL or Postman to send webhook events."
  - "Access to Cisco DevNet Always-On sandbox and credentials."

# OVERVIEW
overview: >
  Build a FastAPI webhook service with five POST endpoints: Dad Jokes, Deck of Cards, Netmiko command,
  RESTCONF request, and NETCONF RPC. Protect endpoints with a shared token, save artifacts under data/,
  and log deterministic markers for autograding. Then configure a Cisco EEM applet on the sandbox device
  that triggers a webhook POST when an interface goes down. Back up the device configuration and include
  it in the repository.

# SETUP
before_you_begin: >
  Open the dev container. Verify imports:
  `python -c "import fastapi, uvicorn, requests, netmiko, ncclient, xmltodict; print('OK')"`
  Ensure you can write to `data/` and `logs/`. Confirm sandbox reachability (TCP 22/443/830).

# RESOURCES
resources:
  - { title: "FastAPI", url: "https://fastapi.tiangolo.com/" }
  - { title: "Uvicorn", url: "https://www.uvicorn.org/" }
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "Netmiko", url: "https://ktbyers.github.io/netmiko/" }
  - { title: "ncclient", url: "https://ncclient.readthedocs.io/" }
  - { title: "xmltodict", url: "https://github.com/martinblech/xmltodict" }
  - { title: "Cisco DevNet Sandboxes", url: "https://developer.cisco.com/site/sandbox/" }
  - { title: "Cisco EEM (Embedded Event Manager) Overview", url: "https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/eem/command/eem-cr-book/eem-cr-a1.html" }

# DELIVERABLES
deliverables:
  - "`src/app.py` (FastAPI app) with ≥5 paths: `/joke`, `/card/draw`, `/device/command`, `/restconf/system`, `/netconf/system` (POST + token)."
  - "`data/` artifacts: `joke.json/txt`, `card.json/txt`, `device_cmd.txt`, `restconf_*.json`, `netconf_*.xml/txt`, and `summary.txt`."
  - "`logs/lab6.log` with required markers from startup, security checks, and each action."
  - "`data/device_running_config.txt` (sandbox running-config backup)."
  - "`data/eem_config.txt` containing the EEM applet configuration you applied."
  - "Pull request open to `main` with all artifacts committed."

# STEPS
steps:
  - title: "Clone the Repository"
    goal: "Get your starter locally."
    actions: |
      Clone your Classroom repo and `cd` into it. Create `src/`, `data/`, and `logs/` if missing.
      Initialize the lab log: `echo 'LAB6_START' >> logs/lab6.log`
    done_when: |
      - Folders exist and initial log marker written.
    log_marker: "LAB6_START"

  - title: "Environment & Packages"
    goal: "Standardize the toolchain."
    actions: |
      Reopen in dev container. Verify FastAPI/Uvicorn/Requests/Netmiko/ncclient/xmltodict imports.
      Append `[STEP 2] Dev Container Started` and `PKG_OK:*` markers to `logs/lab6.log`.
    done_when: |
      - Python 3.11+ confirmed, imports OK.
      - Log contains `[STEP 2] Dev Container Started` and `PKG_OK: fastapi`, `PKG_OK: requests`, `PKG_OK: netmiko`, `PKG_OK: ncclient`.
    log_marker: "[STEP 2] Dev Container Started, PKG_OK: fastapi, PKG_OK: requests, PKG_OK: netmiko, PKG_OK: ncclient"

  - title: "FastAPI App & Security"
    goal: "Expose webhook endpoints with auth and logging."
    actions: |
      Implement `src/app.py` with:
        - FastAPI app and a startup log: `SERVER_STARTED`.
        - Shared token check (e.g., `X-Webhook-Token`) for all POST endpoints.
        - Centralized `log(marker, **fields)` helper writing to `logs/lab6.log`.
        - Pydantic models for request payloads (where applicable).
      Start server: `uvicorn src.app:app --host 0.0.0.0 --port 8000`
    done_when: |
      - Server runs and logs `SERVER_STARTED`.
      - Invalid/missing token returns 401 and logs `SECURITY_VALIDATION=FAIL`.
    log_marker: "SERVER_STARTED, SECURITY_VALIDATION"

  - title: "Endpoint 1 — /joke (Dad Jokes API)"
    goal: "Return a dad joke via webhook-triggered GET."
    actions: |
      Validate token; GET `https://icanhazdadjoke.com/` with `Accept: application/json`.
      Save JSON to `data/joke.json`, text to `data/joke.txt`, return JSON; log markers.
    done_when: |
      - `data/joke.json` and `data/joke.txt` exist and handler returns JSON.
    log_marker: "WEBHOOK_RECEIVED=/joke, JOKE_API_CALLED, RAW_SAVED=joke.json"

  - title: "Endpoint 2 — /card/draw (Deck of Cards)"
    goal: "Create deck and draw a card."
    actions: |
      Create deck then draw 1 card; save `data/card.json` and `data/card.txt`, return summary; log markers.
    done_when: |
      - `data/card.json` and `data/card.txt` exist; response includes card fields.
    log_marker: "WEBHOOK_RECEIVED=/card/draw, CARD_API_CALLED, RAW_SAVED=card.json"

  - title: "Endpoint 3 — /device/command (Netmiko)"
    goal: "Run a show command on sandbox device."
    actions: |
      Connect with Netmiko (`cisco_ios`), run a read-only command (e.g., `show version`).
      Save output to `data/device_cmd.txt`; return short JSON; log markers.
    done_when: |
      - Output saved to `data/device_cmd.txt`.
    log_marker: "WEBHOOK_RECEIVED=/device/command, NETWORK_DEVICE_CALLED, CONNECT_OK: NETMIKO"

  - title: "Endpoint 4 — /restconf/system (RESTCONF)"
    goal: "Query system/platform via RESTCONF."
    actions: |
      Use `Accept: application/yang-data+json`. Save raw `data/restconf_system.json`, return JSON summary; log markers.
    done_when: |
      - Raw JSON saved; summary returned.
    log_marker: "WEBHOOK_RECEIVED=/restconf/system, RESTCONF_CALLED, RAW_SAVED=restconf_system.json"

  - title: "Endpoint 5 — /netconf/system (NETCONF)"
    goal: "Query system/platform via NETCONF RPC."
    actions: |
      Connect with `ncclient.manager.connect(..., port=830)`. Save raw XML `data/netconf_system.xml`,
      parse with `xmltodict`, return JSON summary; log markers.
    done_when: |
      - Raw XML saved; summary JSON returned.
    log_marker: "WEBHOOK_RECEIVED=/netconf/system, NETCONF_CALLED, RAW_SAVED=netconf_system.xml"

  - title: "Cisco EEM Applet — Webhook on Interface-Down"
    goal: "Configure an EEM applet to POST to your webhook when an interface goes down."
    actions: |
      On the sandbox device, create an EEM applet that triggers on link-down syslog (e.g., LINK-3-UPDOWN).
      The action should POST to your FastAPI webhook (token included). Save the exact applet configuration
      you applied to `data/eem_config.txt`. Also back up the running configuration to `data/device_running_config.txt`
      (e.g., via Netmiko `show running-config` or RESTCONF). Log markers when saved.
      Note: If Guestshell/cURL or embedded HTTP client is unavailable, include an alternate IOS-XE-supported
      method or a documented fallback in `data/eem_config.txt`.
    done_when: |
      - `data/eem_config.txt` contains the applet configuration you applied.
      - `data/device_running_config.txt` exists with the device running-config.
      - Log includes `EEM_CONFIG_SAVED` and `CONFIG_BACKUP_SAVED`.
    log_marker: "EEM_CONFIG_SAVED, CONFIG_BACKUP_SAVED"

  - title: "Summary File & Test Run"
    goal: "Produce a human-readable roll-up and validate endpoints with cURL."
    actions: |
      Write `data/summary.txt` with one section per endpoint (joke, card, device, restconf, netconf),
      plus a short note that the EEM applet is configured (reference `data/eem_config.txt`).
      Exercise each endpoint using cURL (include token) and capture HTTP 200s. Log `TESTING_COMPLETE`.
      (Optional) If policy permits, flap a lab interface to test the applet and note the time observed.
    done_when: |
      - `data/summary.txt` exists and includes all sections.
      - Log shows `TESTING_COMPLETE`.
    log_marker: "TESTING_COMPLETE"

  - title: "Finalize & Submit"
    goal: "Close out logs and open PR."
    actions: |
      Stop the server, append `LAB6_END` to `logs/lab6.log`.
      Commit and push all changes. Open a pull request targeting `main`.
    done_when: |
      - PR is open; artifacts present; markers complete.
    log_marker: "LAB6_END"

# FAQ + TROUBLESHOOTING
faq:
  - q: "401 Unauthorized on endpoints."
    a: "Include the shared token header (e.g., `-H 'X-Webhook-Token: <token>'`)."
  - q: "RESTCONF returned HTML, not JSON."
    a: "Use `Accept: application/yang-data+json` and verify the RESTCONF path."
  - q: "NETCONF connection refused."
    a: "Use port 830 and `hostkey_verify=False`; confirm sandbox credentials and reachability."
  - q: "Netmiko errors on connect."
    a: "Check host/IP/port 22, credentials, and device_type=`cisco_ios`."
  - q: "EEM: Device lacks a direct curl/HTTP action."
    a: "Use Guestshell to run curl, or document an IOS-XE-supported alternative in `eem_config.txt`."

tips:
  - title: "Deterministic logging"
    symptom: "Autograder can’t find markers."
    fix: "Log exact tokens; centralize logging in one helper."
  - title: "Security first"
    symptom: "Endpoints accessible without auth."
    fix: "Validate token early; return 401 before doing any work."
  - title: "Artifacts"
    symptom: "Missing files under data/."
    fix: "Create data/ upfront; use the specified filenames."

# GRADING
grading:
  total_points: 75
  rows:
    - { step: "Env", requirement: "Dev container started; packages verified (`PKG_OK:*`)", points: 5 }
    - { step: "Server", requirement: "FastAPI server runs; security validation implemented (`SERVER_STARTED`, `SECURITY_VALIDATION`)", points: 7 }
    - { step: "Joke", requirement: "Joke endpoint returns JSON; artifacts saved (`JOKE_API_CALLED`, `RAW_SAVED=joke.json`)", points: 7 }
    - { step: "Cards", requirement: "Deck create + draw; artifacts saved (`CARD_API_CALLED`, `RAW_SAVED=card.json`)", points: 7 }
    - { step: "Netmiko", requirement: "Device command executed; output saved (`NETWORK_DEVICE_CALLED`, `CONNECT_OK: NETMIKO`)", points: 9 }
    - { step: "RESTCONF", requirement: "RESTCONF call succeeds; JSON parsed; saved (`RESTCONF_CALLED`)", points: 9 }
    - { step: "NETCONF", requirement: "NETCONF RPC succeeds; XML parsed; saved (`NETCONF_CALLED`)", points: 9 }
    - { step: "EEM + Backup", requirement: "Applet config saved and running-config backed up (`EEM_CONFIG_SAVED`, `CONFIG_BACKUP_SAVED`)", points: 10 }
    - { step: "Testing", requirement: "All endpoints validated; summary present (`TESTING_COMPLETE`)", points: 5 }
    - { step: "Submission", requirement: "PR open; `LAB6_START`/`LAB6_END` present; log hygiene", points: 7 }

# AUTOGRADING
autograder:
  log_path: "logs/lab6.log"
  required_markers:
    - "LAB6_START"
    - "[STEP 2] Dev Container Started"
    - "PKG_OK: fastapi"
    - "PKG_OK: requests"
    - "PKG_OK: netmiko"
    - "PKG_OK: ncclient"
    - "SERVER_STARTED"
    - "SECURITY_VALIDATION"
    - "WEBHOOK_RECEIVED=/joke"
    - "JOKE_API_CALLED"
    - "RAW_SAVED=joke.json"
    - "WEBHOOK_RECEIVED=/card/draw"
    - "CARD_API_CALLED"
    - "RAW_SAVED=card.json"
    - "WEBHOOK_RECEIVED=/device/command"
    - "NETWORK_DEVICE_CALLED"
    - "CONNECT_OK: NETMIKO"
    - "WEBHOOK_RECEIVED=/restconf/system"
    - "RESTCONF_CALLED"
    - "RAW_SAVED=restconf_system.json"
    - "WEBHOOK_RECEIVED=/netconf/system"
    - "NETCONF_CALLED"
    - "RAW_SAVED=netconf_system.xml"
    - "EEM_CONFIG_SAVED"
    - "CONFIG_BACKUP_SAVED"
    - "TESTING_COMPLETE"
    - "LAB6_END"

# SUBMISSION CHECKLIST
submission_checklist:
  - "Server runs; token validation enforced on all POST endpoints."
  - "Five endpoints implemented and tested with cURL/Postman."
  - "`data/eem_config.txt` and `data/device_running_config.txt` are present."
  - "Artifacts saved under `data/` using specified filenames."
  - "`logs/lab6.log` includes all required markers."
  - "Pull request open to `main` before deadline."

license: "© 2025 Sheldon Swanson — Classroom use."