# ==========================================
# Course: Software Defined Networking
# Module: Reverse APIs & Event-Driven Automation (Webhooks)
# Purpose: Hands on activity for developing webhook listeners with FastAPI
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 6 — Reverse APIs & Event-Driven Automation (Webhooks)"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 6
time_estimate: "120–150 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "What is a Webhook?"
    content: > 
      A webhook is a user-defined HTTP callback that is triggered by specific events. When an event occurs in a service, 
      the webhook sends a POST request to a specified URL with a payload containing information about the event. This allows 
      for real-time communication between services and enables event-driven architectures.

      Common use cases for webhooks include in networking, where a network device or management system can notify an external
      application of configuration changes, alerts, or status updates. This is in contrast to traditional request/response APIs, 
      where the client must poll the server for updates.

      Example services in networking that utilize webhooks include Cisco's Event-Driven Network Management (EDNM) platform, which 
      can trigger workflows based on network events. Webhooks typically consist of:
      - **URL**: The endpoint where the webhook payload is sent.
      - **Headers**: Metadata about the request, such as content type and authentication tokens.
      - **Payload**: The data sent in the body of the POST request, usually in JSON format.

  - title: "API vs Webhook"
    content: > 
      Traditional APIs operate on a request/response model, where a client sends a request to a server and waits for a response. 
      This often involves polling the server at regular intervals to check for updates, which can lead to inefficiencies and delays.

      In contrast, webhooks follow a push model, where the server proactively sends data to the client when an event occurs. 
      This allows for real-time updates and reduces the need for constant polling, making webhooks more efficient for event-driven scenarios.

      Key differences include:
      - **Initiation**: APIs require the client to initiate requests; webhooks are initiated by the server.
      - **Timing**: APIs may involve delays due to polling intervals; webhooks provide immediate notifications.
      - **Resource Usage**: APIs can consume more resources due to frequent polling; webhooks are more efficient as they only send data when necessary.

  - title: "Webhooks in Networking"
    content: > 
      Webhooks are particularly useful in networking for real-time event notifications. For example, Cisco's Event-Driven Network Management (EDNM) platform utilizes webhooks to trigger workflows based on network events. This allows network administrators to respond quickly to changes in the network environment.

      In a typical webhook setup for networking, the following components are involved:
      - **Event Source**: The network device or management system that generates events (e.g., configuration changes, alerts).
      - **Webhook Listener**: The endpoint that receives webhook notifications (e.g., a FastAPI application).
      - **Payload**: The data sent in the webhook notification, which may include details about the event and relevant context.

      By leveraging webhooks, networking tools can achieve greater automation and responsiveness, enabling more efficient management of network resources.

  - title: "Cisco EDNM & Webhooks"
    content: > 
      Cisco's Event-Driven Network Management (EDNM) platform is a powerful tool that utilizes webhooks to enable event-driven automation in networking. EDNM allows network administrators to define workflows that are triggered by specific events, such as configuration changes, device status updates, or security alerts.

      In an EDNM setup, webhooks play a crucial role in facilitating communication between the network management system and external applications. When an event occurs, EDNM sends a webhook notification to a predefined URL, allowing the receiving application to process the event and take appropriate actions.

      Key features of Cisco EDNM with webhooks include:
      - **Event Triggers**: Define specific events that will trigger webhook notifications.
      - **Custom Payloads**: Configure the data sent in the webhook payload to include relevant information about the event.
      - **Integration**: Easily integrate with other systems and applications using webhooks, enabling seamless automation across different platforms.

      By leveraging webhooks in Cisco EDNM, network administrators can create dynamic and responsive workflows that enhance network management and improve operational efficiency.

      An example configuration snippet for setting up a webhook in Cisco EDNM might look like the example below:

    code_block:
      language: "bash"
      code: |
        router(config)# event manager applet Webhook_Example
        router(config-applet)# event syslog pattern "LINK-3-UPDOWN"
        router(config-applet)# action 1.0 cli command "enable"
        router(config-applet)# action 1.1 cli command "configure terminal"
        router(config-applet)# action 1.2 cli command "interface GigabitEthernet0/1"
        router(config-applet)# action 1.3 cli command "description Link is up"
        router(config-applet)# action 1.4 cli command "end"
        router(config-applet)# action 1.5 http post url "http://your-webhook-url" body "Interface GigabitEthernet0/1 is up"
        router(config-applet)# action 1.6 exit
        router(config-applet)# exit
        router(config)# exit

    code_notes: |
      In this example, the Event Manager applet is configured to listen for syslog messages indicating a link status change. When the specified 
      event occurs, the applet executes a series of CLI commands to update the interface description and then sends a webhook notification to 
      the specified URL with a message about the link status change. This demonstrates how webhooks can be used in conjunction with network 
      events to automate responses and notify external systems.

  - title: "Creating Webhook Listeners with FastAPI"
    content: > 
      FastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.7+ based on standard Python type hints. It is particularly well-suited for creating webhook listeners due to its simplicity and efficiency.

      To create a webhook listener with FastAPI, you typically define an endpoint that accepts POST requests. The endpoint processes the incoming JSON payload and performs actions based on the event data.

      Here’s a basic example of a FastAPI webhook listener:

    code_block:
      language: "python"
      code: |
        from fastapi import FastAPI

        app = FastAPI()

        @app.post("/webhook")
        async def handle_webhook(payload: dict):
            # Process the incoming webhook payload
            print("Received webhook payload:", payload)
            return {"status": "success"}

    code_notes: |
      In this example, the FastAPI application defines a POST endpoint at `/webhook`. When a webhook notification is received, the `handle_webhook` function is called with the JSON payload parsed into a Python dictionary. The function can then process the payload as needed and return a response.

      To run the FastAPI application, you can use Uvicorn, an ASGI server:

      ```bash
      pip install uvicorn
      uvicorn main:app --reload
      ```
      This will start the server, and you can test the webhook listener by sending a POST request with a JSON payload using tools like cURL or Postman.

      ```bash
      curl -X POST "http://localhost:8000/webhook" -H "Content-Type: application/json" -d '{"event": "test_event", "data": "sample_data"}'
      ```
  
  - title: "Security Considerations for Webhooks"
    content: > 
      When implementing webhooks, it is crucial to consider security aspects to protect against unauthorized access and ensure the integrity of the data being transmitted. Here are some best practices for securing webhooks:

      1. **Validation**: Always validate incoming webhook requests to ensure they originate from a trusted source. This can be done by checking headers, IP addresses, or using shared secrets.

      2. **Authentication**: Implement authentication mechanisms such as HMAC signatures or bearer tokens to verify the authenticity of the webhook requests.

      3. **Rate Limiting**: Apply rate limiting to prevent abuse and mitigate denial-of-service (DoS) attacks.

      4. **Payload Size Limits**: Set limits on the size of incoming payloads to avoid resource exhaustion.

      5. **HTTPS**: Use HTTPS to encrypt data in transit and protect against eavesdropping and man-in-the-middle attacks.


#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================

objectives:
  - "Explain what a Webhook is and how it differs from traditional request/response APIs."
  - "Describe event-driven automation in networking (e.g., Cisco EDNM) and how webhooks trigger workflows."
  - "Stand up a FastAPI webhook listener that accepts JSON payloads via POST."
  - "Use cURL to simulate webhook events and validate request handling."
  - "Integrate external APIs (Dad Jokes, Deck of Cards) as event-driven actions."
  - "Trigger network device interactions (Netmiko) from webhook events."
  - "Apply basic webhook security: validation, limits, and token checks."
  - "Produce logs and artifacts suitable for autograding."

python_version: "3.11"
accounts: ["GitHub"]
devices:
  - "Local FastAPI webhook server"
  - "Cisco DevNet Always-On Sandbox (Catalyst 8k/9k)"

overview: >
  Webhooks flip the usual API pattern: instead of polling, the server calls you when events happen.
  You’ll build a FastAPI listener, drive it with cURL, trigger external APIs, and tie events to
  network device actions (Netmiko). This is the backbone of event-driven network automation.

before_you_begin: >
  Open the dev container, confirm `python --version` prints 3.11+, and ensure outbound HTTPS works.
  Create `logs/`, `data/webhook_payloads/`, `data/responses/`, and `data/curl_tests/` if missing.

resources:
  - { title: "FastAPI", url: "https://fastapi.tiangolo.com/" }
  - { title: "Uvicorn", url: "https://www.uvicorn.org/" }
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "Netmiko", url: "https://ktbyers.github.io/netmiko/" }
  - { title: "RFC 8040 — RESTCONF", url: "https://www.rfc-editor.org/rfc/rfc8040" }
  - { title: "RFC 6241 — NETCONF", url: "https://www.rfc-editor.org/rfc/rfc6241" }
  - { title: "Cisco DevNet Sandboxes", url: "https://developer.cisco.com/site/sandbox/" }

faq:
  - q: "Why did I get HTML instead of JSON from an API?"
    a: "Set `Accept: application/json` (or `application/yang-data+json` for RESTCONF)."
  - q: "My webhook server won’t start."
    a: "Install deps in the dev container: `pip install fastapi uvicorn` or use `requirements.txt`."
  - q: "Deck of Cards draw fails."
    a: "Create a deck first, save the `deck_id`, and pass it to the draw endpoint."

deliverables:
  readme_summary: "Standardized README explaining goals, overview, resources, grading, and tips."
  instructions_summary: "Step-by-step INSTRUCTIONS with required log markers and artifacts."
  files:
    src:
      - "src/basic_webhook_server.py"
      - "src/joke_webhook_server.py"
      - "src/card_webhook_server.py"
      - "src/network_webhook_server.py"
    data:
      - "data/webhook_payloads/joke_request.json"
      - "data/webhook_payloads/card_draw.json"
      - "data/webhook_payloads/network_device_check.json"
      - "data/responses/"
      - "data/curl_tests/test_webhooks.sh"
    logs:
      - "logs/basic_webhook.log"
      - "logs/joke_webhook.log"
      - "logs/card_webhook.log"
      - "logs/network_webhook.log"
      - "logs/curl_tests.log"
      - "logs/DEVCONTAINER_STATUS.txt"

grading:
  total_points: 75
  rows:
    - { step: "1", requirement: "Dev container ready; dependencies installed", points: 3 }
    - { step: "2", requirement: "Reverse API concepts + EDNM documented", points: 3 }
    - { step: "3", requirement: "Basic FastAPI server with /events endpoint", points: 8 }
    - { step: "3", requirement: "Server logs requests and handles errors", points: 4 }
    - { step: "4", requirement: "cURL sends JSON successfully", points: 5 }
    - { step: "4", requirement: "Error cases tested and handled", points: 3 }
    - { step: "5", requirement: "Dad Jokes integration via webhook", points: 7 }
    - { step: "5", requirement: "Proper response handling and errors", points: 3 }
    - { step: "6", requirement: "Deck of Cards integration; multiple events", points: 6 }
    - { step: "6", requirement: "Deck state management", points: 4 }
    - { step: "7", requirement: "Netmiko device interaction via webhook", points: 8 }
    - { step: "7", requirement: "Device output captured and returned", points: 4 }
    - { step: "8", requirement: "Security and validation implemented", points: 5 }
    - { step: "8", requirement: "Config externalized; robust errors", points: 3 }
    - { step: "9", requirement: "Comprehensive tests + docs", points: 4 }
    - { step: "10", requirement: "End-to-end demo works", points: 5 }
    - { step: "11", requirement: "Submission quality; required logs present", points: 3 }

tips:
  - title: "Port in use"
    symptom: "Uvicorn fails on 8000"
    fix: "Kill the process or run `--port 8001`."
  - title: "cURL refused"
    symptom: "Connection refused to localhost"
    fix: "Bind to 0.0.0.0 and ensure the server is running."
  - title: "Missing logs"
    symptom: "Autograder can’t find markers"
    fix: "Use the provided `log(...)` helper and correct file paths."

autograder:
  log_path: "logs/*.log"
  required_markers:
    - "LAB6_START"
    - "SERVER_STARTED"
    - "CURL_TEST"
    - "WEBHOOK_RECEIVED"
    - "JOKE_API_CALLED"
    - "CARD_API_CALLED"
    - "NETWORK_DEVICE_CALLED"
    - "SECURITY_VALIDATION"
    - "TESTING_COMPLETE"
    - "LAB6_COMPLETE"

submission_checklist:
  - "All four servers present under `src/` and start without tracebacks."
  - "cURL scripts under `data/curl_tests/` exercise each event type."
  - "Artifacts saved under `data/responses/`."
  - "Logs contain all required markers for each phase."
  - "README/INSTRUCTIONS rendered from template; PR passes Verify Docs."

steps:
  - title: "Clone the Repository & Setup"
    goal: "Get workspace ready; confirm environment."
    actions: |
      Clone your Classroom repo, open in VS Code, and reopen in the dev container.
      Verify Python and dependencies; create the data/logs folders if needed.
    done_when: |
      - Dev container shows READY
      - Dependencies installed (fastapi, uvicorn, requests)
      - `logs/DEVCONTAINER_STATUS.txt` updated
    log_marker: "LAB6_START"

  - title: "Understand Reverse APIs (Webhooks)"
    goal: "Grasp polling vs push; relate to EDNM."
    actions: |
      Read the README section on webhooks, skim EDNM examples, and note webhook anatomy:
      URL, headers, JSON payload.
    done_when: "You can explain polling vs push and list webhook parts."
    log_marker: "CONCEPT_REVIEW"

  - title: "Build Basic FastAPI Webhook Server"
    goal: "Receive JSON via POST and log it."
    actions: |
      Implement `src/basic_webhook_server.py` with POST `/events`, parse JSON, log to file,
      return `{ "status": "ok" }`, and handle bad input cleanly.
      Start with `uvicorn basic_webhook_server:app --host 0.0.0.0 --port 8000`.
    done_when: "Server runs and accepts POSTs without crashing."
    log_marker: "SERVER_STARTED"

  - title: "Test Webhook with cURL"
    goal: "Simulate events and validate handling."
    actions: |
      Create sample payloads under `data/webhook_payloads/` and send them with cURL to `/events`.
      Include one malformed JSON test and record results to `logs/curl_tests.log`.
    done_when: "Valid and invalid payloads both handled; logs updated."
    log_marker: "CURL_TEST"

  - title: "Joke API via Webhook"
    goal: "Trigger external API based on event."
    actions: |
      Implement `src/joke_webhook_server.py` that responds to `{"event":"joke_request"}` by
      calling Dad Jokes (`Accept: application/json`), returning the joke and logging the call.
    done_when: "Jokes returned and logged."
    log_marker: "JOKE_API_CALLED"

  - title: "Deck of Cards via Webhook"
    goal: "Support multiple event types and state."
    actions: |
      Implement `src/card_webhook_server.py` that handles `new_deck`, `draw`, `shuffle`,
      persists `deck_id`, and logs actions and outcomes.
    done_when: "Deck created/drawn/shuffled via webhook events."
    log_marker: "CARD_API_CALLED"

  - title: "Network Device via Webhook"
    goal: "Trigger Netmiko interactions from events."
    actions: |
      Implement `src/network_webhook_server.py` that accepts device/action params,
      connects to DevNet sandbox with Netmiko, runs show commands, returns structured data,
      and logs connection/command results and errors.
    done_when: "Device output returned; errors handled gracefully."
    log_marker: "NETWORK_DEVICE_CALLED"

  - title: "Security & Validation"
    goal: "Harden the listener."
    actions: |
      Add payload validation, size limits, optional bearer token check, and input sanitization.
      Externalize non-secret config to `webhook_config.json`.
    done_when: "Bad inputs rejected; config read from file."
    log_marker: "SECURITY_VALIDATION"

  - title: "Comprehensive Testing & Docs"
    goal: "Exercise all endpoints and document."
    actions: |
      Write cURL scripts for every event type, capture responses to `data/responses/`,
      and document formats and expected outcomes.
    done_when: "All endpoints tested; artifacts present."
    log_marker: "TESTING_COMPLETE"

  - title: "Demo & Submit"
    goal: "Run the full workflow and submit."
    actions: |
      Run your most capable server, execute a scripted demo of all features,
      ensure logs contain the required markers, commit/push, and open a PR.
    done_when: "PR is open and Verify Docs is green."
    log_marker: "LAB6_COMPLETE"

license: "© 2025 Your Name — Classroom use."

